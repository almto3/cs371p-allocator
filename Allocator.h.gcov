        -:    0:Source:Allocator.h
        -:    0:Graph:TestAllocator.gcno
        -:    0:Data:TestAllocator.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// ------------------------------
        -:    2:// projects/allocator/Allocator.h
        -:    3:// Copyright (C) 2015
        -:    4:// Glenn P. Downing
        -:    5:// ------------------------------
        -:    6:
        -:    7:#ifndef Allocator_h
        -:    8:#define Allocator_h
        -:    9:
        -:   10:// --------
        -:   11:// includes
        -:   12:// --------
        -:   13:
        -:   14:#include <cassert>   // assert
        -:   15:#include <cstddef>   // ptrdiff_t, size_t
        -:   16:#include <stdexcept> // invalid_argument
        -:   17:#include <iostream>
        -:   18:
        -:   19:using namespace std;
        -:   20:
        -:   21:
        -:   22:// ---------
        -:   23:// Allocator
        -:   24:// ---------
        -:   25:
        -:   26:template <typename T, std::size_t N>
        -:   27:class Allocator {
        -:   28:    public:
        -:   29:        // --------
        -:   30:        // typedefs
        -:   31:        // --------
        -:   32:
        -:   33:        typedef T                 value_type;
        -:   34:
        -:   35:        typedef std::size_t       size_type;
        -:   36:        typedef std::ptrdiff_t    difference_type;
        -:   37:
        -:   38:        typedef       value_type*       pointer;
        -:   39:        typedef const value_type* const_pointer;
        -:   40:
        -:   41:        typedef       value_type&       reference;
        -:   42:        typedef const value_type& const_reference;
        -:   43:
        -:   44:    public:
        -:   45:        // -----------
        -:   46:        // operator ==
        -:   47:        // -----------
        -:   48:
        -:   49:        friend bool operator == (const Allocator&, const Allocator&) {
        -:   50:            return true;        // this is correct
        -:   51:        }                                              
        -:   52:
        -:   53:        // -----------
        -:   54:        // operator !=
        -:   55:        // -----------
        -:   56:
        -:   57:        friend bool operator != (const Allocator& lhs, const Allocator& rhs) {
        -:   58:            return !(lhs == rhs);
        -:   59:        }
        -:   60:
        -:   61:    private:
        -:   62:        // ----
        -:   63:        // data
        -:   64:        // ----
        -:   65:        int s1 = 0, s2 = 0;
        -:   66:
        -:   67:        char a[N];
        -:   68:
        -:   69:        // -----
        -:   70:        // valid
        -:   71:        // -----
        -:   72:
        -:   73:        /**
        -:   74:         * O(1) in space
        -:   75:         * O(n) in time
        -:   76:         * Basically, this version checks that the sentinels give correct values, doesn't check for the validity of the data, also checks that the first and last sentinels match each other
        -:   77:         */
function _ZNK9AllocatorIdLm100EE5validEv called 8 returned 100% blocks executed 80%
function _ZNK9AllocatorIcLm127EE5validEv called 1 returned 100% blocks executed 80%
function _ZNK9AllocatorIdLm50EE5validEv called 1 returned 100% blocks executed 80%
function _ZNK9AllocatorIcLm6EE5validEv called 0 returned 0% blocks executed 0%
function _ZNK9AllocatorIiLm100EE5validEv called 37 returned 100% blocks executed 80%
       47:   78:        bool valid () const {
        -:   79:
       47:   80:            int i = 0;  //i is position/value of the sentinel
       47:   81:            int sen1 = 0, sen2 = 0;
        -:   82:
        -:   83:            //while loop will read the sentinels until it reaches the end of the heap
      174:   84:            while (i < N){
branch  0 taken 56%
branch  1 taken 44% (fallthrough)
branch  2 taken 50%
branch  3 taken 50% (fallthrough)
branch  4 taken 50%
branch  5 taken 50% (fallthrough)
branch  6 never executed
branch  7 never executed
branch  8 taken 65%
branch  9 taken 35% (fallthrough)
        -:   85:                
       80:   86:                sen1 = (*this)[i];
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 never executed
call    4 returned 100%
       80:   87:                i = i + 4 + abs(sen1);
        -:   88:
       80:   89:                sen2 = (*this)[i];
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 never executed
call    4 returned 100%
       80:   90:                i += 4;
        -:   91:
       80:   92:                if (sen1 != sen2){      //sentinels don't match 
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
branch  6 never executed
branch  7 never executed
branch  8 taken 0% (fallthrough)
branch  9 taken 100%
    #####:   93:                    return false;
        -:   94:                }
        -:   95:            }
        -:   96:            
        -:   97:            //i has reached the end without any problems 
       47:   98:            if (i == N){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 never executed
branch  7 never executed
branch  8 taken 100% (fallthrough)
branch  9 taken 0%
       47:   99:                return true;
        -:  100:            }
        -:  101:            //there's a problem with the heap
        -:  102:            else{
    #####:  103:                return false;
        -:  104:            }
        -:  105:        }
        -:  106:
        -:  107:        /**
        -:  108:         * O(1) in space
        -:  109:         * O(1) in time
        -:  110:         * Friend Tests for the unit tests
        -:  111:         * https://code.google.com/p/googletest/wiki/AdvancedGuide#Private_Class_Members
        -:  112:         */
        -:  113:        FRIEND_TEST(TestAllocator2, index);
        -:  114:         
        -:  115:        FRIEND_TEST(TestAllocator2, Allocator1);
        -:  116:        FRIEND_TEST(TestAllocator2, Allocator2);
        -:  117:        FRIEND_TEST(TestAllocator2, Allocator3);
        -:  118:
        -:  119:        FRIEND_TEST(TestAllocator2, deallocate1);
        -:  120:        FRIEND_TEST(TestAllocator2, deallocate2);
        -:  121:        FRIEND_TEST(TestAllocator2, deallocate3); 
        -:  122:
        -:  123:        FRIEND_TEST(TestAllocator2, allocate1);
        -:  124:        FRIEND_TEST(TestAllocator2, allocate2);
        -:  125:        FRIEND_TEST(TestAllocator2, allocate3);
        -:  126:
        -:  127:        FRIEND_TEST(TestAllocator2, valid1);
        -:  128:        FRIEND_TEST(TestAllocator2, valid2);
        -:  129:        FRIEND_TEST(TestAllocator2, valid3);
        -:  130:        FRIEND_TEST(TestAllocator2, valid4);
        -:  131:
function _ZN9AllocatorIdLm100EEixEi called 26 returned 100% blocks executed 100%
function _ZN9AllocatorIcLm6EEixEi called 0 returned 0% blocks executed 0%
function _ZN9AllocatorIcLm127EEixEi called 4 returned 100% blocks executed 100%
function _ZN9AllocatorIdLm50EEixEi called 4 returned 100% blocks executed 100%
function _ZN9AllocatorIiLm100EEixEi called 113 returned 100% blocks executed 100%
      147:  132:        int& operator [] (int i) {
      147:  133:            return *reinterpret_cast<int*>(&a[i]);
        -:  134:        }
        -:  135:
        -:  136:    public:
        -:  137:        // ------------
        -:  138:        // constructors
        -:  139:        // ------------
        -:  140:
        -:  141:        /**
        -:  142:         * O(1) in space
        -:  143:         * O(1) in time
        -:  144:         * throw a bad_alloc exception, if N is less than sizeof(T) + (2 * sizeof(int))
        -:  145:         */
function _ZN9AllocatorIdLm100EEC2Ev called 4 returned 100% blocks executed 60%
function _ZN9AllocatorIcLm127EEC2Ev called 1 returned 100% blocks executed 60%
function _ZN9AllocatorIdLm50EEC2Ev called 1 returned 100% blocks executed 60%
function _ZN9AllocatorIcLm6EEC2Ev called 1 returned 0% blocks executed 50%
function _ZN9AllocatorIiLm100EEC2Ev called 15 returned 100% blocks executed 60%
       22:  146:        Allocator () {//initializes sentinels 
        -:  147:            
       22:  148:            if ( N < ( sizeof(T) + (2 * sizeof(int)) ) )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
branch  8 taken 0% (fallthrough)
branch  9 taken 100%
        1:  149:                throw std::bad_alloc ();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 returned 100%
call   10 returned 100%
call   11 returned 0%
call   12 never executed
call   13 never executed
call   14 never executed
        -:  150:
       21:  151:            int sen = N - 8;
        -:  152:            
       21:  153:            (*this)[0] = sen;
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 never executed
call    4 returned 100%
       21:  154:            (*this)[N-4] = sen;
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 never executed
call    4 returned 100%
        -:  155:    
       21:  156:            assert(valid());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
call    4 returned 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
call    7 never executed
call    8 returned 100%
branch  9 taken 0% (fallthrough)
branch 10 taken 100%
call   11 never executed
call   12 never executed
branch 13 never executed
branch 14 never executed
call   15 never executed
call   16 returned 100%
branch 17 taken 0% (fallthrough)
branch 18 taken 100%
call   19 never executed
       21:  157:        }
        -:  158:
        -:  159:        // Default copy, destructor, and copy assignment
        -:  160:        // Allocator  (const Allocator&);
        -:  161:        // ~Allocator ();
        -:  162:        // Allocator& operator = (const Allocator&);
        -:  163:
        -:  164:        // --------
        -:  165:        // allocate
        -:  166:        // --------
        -:  167:
        -:  168:        /**
        -:  169:         * O(1) in space
        -:  170:         * O(n) in time
        -:  171:         * after allocation there must be enough space left for a valid block
        -:  172:         * the smallest allowable block is sizeof(T) + (2 * sizeof(int))
        -:  173:         * choose the first block that fits
        -:  174:         * throw a bad_alloc exception, if n is invalid
        -:  175:         */
function _ZN9AllocatorIdLm100EE8allocateEm called 4 returned 100% blocks executed 63%
function _ZN9AllocatorIiLm100EE8allocateEm called 18 returned 89% blocks executed 83%
       22:  176:        pointer allocate (size_type n) {//finds first fit 
        -:  177:            
       22:  178:            if ((n * sizeof(T)) > (N - 8))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 6% (fallthrough)
branch  3 taken 94%
        1:  179:                throw std::bad_alloc ();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 returned 100%
call    4 returned 100%
call    5 returned 0%
        -:  180:            
       21:  181:            int i = 0;          //i is position of the first sentinel
       21:  182:            int sen = 0;        //value of sentinel
       21:  183:            bool ex = false;    //do we need to allocate more space than the user wants?
        -:  184:            
       49:  185:            while (i < N){
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 96%
branch  3 taken 4% (fallthrough)
       27:  186:                sen = (a[i+3] << 24) | (a[i+2] << 16) | (a[i+1] << 8) | (a[i]); //legacy code
        -:  187:                
       27:  188:                if (sen <= 0 ){      //check if it's occupied or free
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 30% (fallthrough)
branch  3 taken 70%
        7:  189:                    i = i + 8 + abs( sen );
        7:  190:                    continue;
        -:  191:                }
        -:  192:
       20:  193:                else if (sen == (n * sizeof(T) ) ){     //wooohooo, it's a perfect fit
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 6% (fallthrough)
branch  3 taken 94%
        1:  194:                    break;
        -:  195:                }
        -:  196:
       19:  197:                else if (sen < (n * sizeof(T) ) ){  //check if block is free, but not big enough
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  198:                    i = i + 8 + abs( sen );
    #####:  199:                    continue;       
        -:  200:                }
       19:  201:                else if ( (sen - (n * sizeof(T) ) ) < ( sizeof(T) + 8 ) ){  //check if it's free, but we need to give user more space                    
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        2:  202:                    ex = true;
        2:  203:                    break;
        -:  204:                }
        -:  205:                else{       //it fits!
       17:  206:                    break;
        -:  207:                }
        -:  208:            }
        -:  209:
        -:  210:            // by this point, i is either the end of the heap or the address to a valid block        
       21:  211:            if (i == N)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 6% (fallthrough)
branch  3 taken 94%
        1:  212:                throw std::bad_alloc ();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 returned 100%
call    4 returned 100%
call    5 returned 0%
        -:  213:
       20:  214:            if(sen == (n * sizeof(T)) ){        //perfect fit, just change pos to neg
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 6% (fallthrough)
branch  3 taken 94%
        1:  215:                (*this)[i] = -(*this)[i];
call    0 never executed
call    1 never executed
call    2 returned 100%
call    3 returned 100%
        1:  216:                (*this)[i + sen + 4] = (*this)[i]; 
call    0 never executed
call    1 never executed
call    2 returned 100%
call    3 returned 100%
        -:  217:            }
        -:  218:
        -:  219:            else {      //not a perfect fit
       19:  220:                if(ex){
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  221:                
        2:  222:                    (*this)[i] = - (n * sizeof(T) ) - (sen - (n * sizeof(T) ) );
call    0 returned 100%
call    1 never executed
        2:  223:                    (*this)[i + 4 + - (*this)[i] ] = - (n * sizeof(T) ) - (sen - (n * sizeof(T) ) );
call    0 returned 100%
call    1 returned 100%
call    2 never executed
call    3 never executed
        -:  224:                }
        -:  225:                else{
        -:  226:
       17:  227:                    (*this)[i] = - (n * sizeof(T) );                         //change 1st sen
call    0 returned 100%
call    1 returned 100%
       17:  228:                    (*this)[i + 4 + (n * sizeof(T)) ] = - (n * sizeof(T) ) ;  //change 2nd sen
call    0 returned 100%
call    1 returned 100%
        -:  229:
       17:  230:                    int x = sen - 8 - (n * sizeof(T) );
        -:  231:
       17:  232:                    (*this)[i + 8 + (n * sizeof(T)) ] = x;  //change 3rd sen
call    0 returned 100%
call    1 returned 100%
        -:  233:                    
        -:  234:                    //vv, code works, but not sure why we're skipping 3 ints instead of tw, maybe i just had too much coffee?
       17:  235:                    (*this)[i + 12 + (n * sizeof(T)) + x] = x;  //change 4th sen
call    0 returned 100%
call    1 returned 100%
        -:  236:                }
        -:  237:            }
       20:  238:            assert(valid());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
call    4 returned 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
call    7 never executed
        -:  239:            //we're returning the address to the data, not the sentinel!
       20:  240:            pointer pi = (pointer)(*this)[i+4];     //casting to a pointer type
call    0 returned 100%
call    1 returned 100%
       20:  241:            return pi;
        -:  242:           }             
        -:  243:
        -:  244:        // ---------
        -:  245:        // construct
        -:  246:        // ---------
        -:  247:
        -:  248:        /**
        -:  249:         * O(1) in space
        -:  250:         * O(1) in time
        -:  251:         */
function _ZN9AllocatorIiLm100EE9constructEPiRKi called 0 returned 0% blocks executed 0%
function _ZN9AllocatorIdLm100EE9constructEPdRKd called 0 returned 0% blocks executed 0%
    #####:  252:        void construct (pointer p, const_reference v) {
    #####:  253:            new (p) T(v);                               // this is correct and exempt
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  254:            assert(valid());
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
    #####:  255:        }                           // from the prohibition of new
        -:  256:
        -:  257:        // ----------
        -:  258:        // deallocate
        -:  259:        // ----------
        -:  260:
        -:  261:        /**
        -:  262:         * O(1) in space
        -:  263:         * O(1) in time
        -:  264:         * after deallocation adjacent free blocks must be coalesced
        -:  265:         * throw an invalid_argument exception, if p is invalid
        -:  266:         * deallocate takes an occupied block and frees it, will throw an exception in case the given pointer does not point to the first sentinel of an occupied block
        -:  267:         */
function _ZN9AllocatorIdLm100EE10deallocateEPdm called 0 returned 0% blocks executed 0%
function _ZN9AllocatorIiLm100EE10deallocateEPim called 1 returned 0% blocks executed 13%
        1:  268:        void deallocate (pointer p, size_type) {
        -:  269:            
        1:  270:            bool senbfr = false, senafr = false;        //true is the sentinels are free
        1:  271:            int sen = 0;
        -:  272:           
        1:  273:            if( (*p < 4) || ( *p > (N-sizeof(int)-sizeof(T)) ) ){
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
branch  6 never executed
branch  7 never executed
        1:  274:                throw std::invalid_argument( "received neg value of p " );
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
call   14 never executed
call   15 returned 100%
call   16 returned 100%
call   17 returned 100%
branch 18 taken 100% (fallthrough)
branch 19 taken 0% (throw)
call   20 returned 100%
branch 21 taken 100% (fallthrough)
branch 22 taken 0% (throw)
call   23 returned 100%
call   24 returned 100%
call   25 returned 0%
call   26 never executed
call   27 never executed
call   28 never executed
call   29 never executed
        -:  275:            }
        -:  276:                
    #####:  277:            p = p - sizeof(int);
    #####:  278:            sen = -(*this)[*p];         //sen will always be positive after this point
call    0 never executed
call    1 never executed
        -:  279:
    #####:  280:            if (sen < 0){
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  281:                throw std::invalid_argument( "received pos value of sen, which means it's already free ");
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
call   14 never executed
call   15 never executed
call   16 never executed
branch 17 never executed
branch 18 never executed
call   19 never executed
branch 20 never executed
branch 21 never executed
call   22 never executed
call   23 never executed
call   24 never executed
call   25 never executed
call   26 never executed
call   27 never executed
        -:  282:            }
    #####:  283:            if (*p > 4){        // not at beginning 
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  284:                //read the sentinel before it and set senbfr
    #####:  285:                int senb = (*this)[*p - sizeof(int) ];
call    0 never executed
call    1 never executed
        -:  286:                
    #####:  287:                if (senb > 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  288:                    senbfr = true;
        -:  289:            }
    #####:  290:            if ( (N - *p - sen - (2 * sizeof(int))) > 0 ){       //not at the end
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  291:                //read the sentinel after it and set senafr
    #####:  292:                int sena = (*this)[*p + sen + (2 * sizeof(int))];
call    0 never executed
call    1 never executed
    #####:  293:                if (sena > 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  294:                    senafr = true;
        -:  295:            }
        -:  296:
    #####:  297:            if(senbfr && senafr){
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:  298:                
    #####:  299:                int sena = (*this)[ (*p) + (2* sizeof(int)) + sen];         //value of sen after
call    0 never executed
call    1 never executed
    #####:  300:                int senb = (*this)[ (*p) - sizeof(int)];         //value of sen before
call    0 never executed
call    1 never executed
    #####:  301:                int sen_new = sen + senb + sena + 16;           //value of the new sentinels (combined block)
        -:  302:
    #####:  303:                (*this)[ (*p) - (2 * sizeof(int)) - senb ] = sen_new;   //changing the 1st sen
call    0 never executed
call    1 never executed
    #####:  304:                (*this)[ (*p) + (2 * sizeof(int)) + sen + sena + 8 ] = sen_new;    //changing the 6th/last sen
call    0 never executed
call    1 never executed
        -:  305:            }
    #####:  306:            else if (senbfr && !senafr){    //coalesce with prev chunk
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:  307:
    #####:  308:                int senb = (*this)[(*p) - sizeof(int)];         //value of sen before
call    0 never executed
call    1 never executed
    #####:  309:                int sen_new = sen + senb + 8;                   //value of the new sentinels (combined block)
        -:  310:
    #####:  311:                (*this)[ (*p) - (2 * sizeof(int)) - senb ] = sen_new;   //changing the 1st sen
call    0 never executed
call    1 never executed
    #####:  312:                (*this)[ (*p) + (2 * sizeof(int)) + sen ] = sen_new;    //changing the 4th/last sen
call    0 never executed
call    1 never executed
        -:  313:            }
    #####:  314:            else if (!senbfr && senafr){    //coalesce with next chunk
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:  315:                
    #####:  316:                int sena = (*this)[ (*p) + (2* sizeof(int)) + sen];         //value of sen after
call    0 never executed
call    1 never executed
    #####:  317:                int sen_new = abs(sen) + sena + 8;           //value of the new sentinels (combined block)
        -:  318:
    #####:  319:                (*this)[ (*p) ] = sen_new;   //changing the 1st sen
call    0 never executed
call    1 never executed
    #####:  320:                (*this)[ (*p) + (sizeof(int)) + sen_new ] = sen_new;    //changing the 4th/last sen
call    0 never executed
call    1 never executed
        -:  321:            }
        -:  322:            else{
    #####:  323:                (*this)[*p] = -(*this)[*p];
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  324:                (*this)[*p + sen + 4] = -(*this)[*p];
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  325:            }
    #####:  326:            assert(valid());
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
    #####:  327:        }
        -:  328:
        -:  329:        // -------
        -:  330:        // destroy
        -:  331:        // -------
        -:  332:
        -:  333:        /**
        -:  334:         * O(1) in space
        -:  335:         * O(1) in time
        -:  336:         */
function _ZN9AllocatorIiLm100EE7destroyEPi called 0 returned 0% blocks executed 0%
function _ZN9AllocatorIdLm100EE7destroyEPd called 0 returned 0% blocks executed 0%
    #####:  337:        void destroy (pointer p) {
        -:  338:            p->~T();               // this is correct
    #####:  339:            assert(valid());
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
    #####:  340:        }
        -:  341:
        -:  342:        /**
        -:  343:         * O(1) in space
        -:  344:         * O(1) in time
        -:  345:         * interprets bytes to ints from the heap
        -:  346:         */
function _ZNK9AllocatorIdLm100EEixEi called 20 returned 100% blocks executed 100%
function _ZNK9AllocatorIcLm127EEixEi called 2 returned 100% blocks executed 100%
function _ZNK9AllocatorIdLm50EEixEi called 2 returned 100% blocks executed 100%
function _ZNK9AllocatorIcLm6EEixEi called 0 returned 0% blocks executed 0%
function _ZNK9AllocatorIiLm100EEixEi called 137 returned 100% blocks executed 100%
      161:  347:        const int& operator [] (int i) const {
      161:  348:            return *reinterpret_cast<const int*>(&a[i]);
        -:  349:        }
        -:  350:};
        -:  351:
        -:  352:    //takes an it and return the byte representation of it (small endian)
function _Z10intToBytesi called 0 returned 0% blocks executed 0%
    #####:  353:    vector<unsigned char> intToBytes(int z){
    #####:  354:         vector<unsigned char> v (4);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  355:         for (int i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
    #####:  356:             v[3 - i] = (z >> (i * 8));
call    0 never executed
    #####:  357:         return v;
call    0 never executed
        -:  358:    }
        -:  359:
        -:  360:
        -:  361:#endif // Allocator_h
